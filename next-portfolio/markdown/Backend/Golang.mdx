# Golang

## Syntax

### Import Package

```go
package main
```

### Import

```go
import "fmt"
import "time"
```

or

```go
import (
	"fmt"
	"time"
)
```

### main function

```go
func main () { // The { must be on the same line of the function (google style)
	// This is single line comment

	/*
	this is
	a multiline
	comment!
	*/

	time.Sleep(1 * time.Second) // The ; is optional (like JS and TS)
	fmt.Println("Hello World")

}
```

### declare variables

```go
func main () {
	// 1. declare a variable, default value is 0
	var a int
	fmt.Println("a =", a) // b = 2
	fmt.Printf("type of a = %T\n", a) // type of a = int

	// 2. declare a variable, initialise the value
	var b int = 2
	fmt.Println("b =", b) // b = 2
	fmt.Printf("type of b = %T\n", b) // type of b = int

	// 3. Omit the data type
	var c = 3
	fmt.Println("c =", c) // c = 3
	fmt.Printf("type of c = %T\n", c) // type of c = int

	// 4. Omit var, auto match
	// := can only be used in the function block
	d := 3
	fmt.Println("d =", d) // d = 3
	fmt.Printf("type of d = %T\n", d) // type of d = int

	// declare multiple variables
	var xx, yy int = 100, 200
	fmt.Println("xx =", xx, "yy =", yy)

	var (
		vv int = 100
		jj bool = true
	)
	fmt.Println("vv =", vv, "jj =", jj)
}
```

### const

```go
const (
	// Adding a 'iota' in the const(), iota will increase 1 by each line. iota in the first line is 0
	BEIJING = iota  // iota = 0
	SHANGHAI		// iota = 1
	SHENZHEN		// iota = 2
)

const (
    a, b = iota + 1, iota + 2	// iota = 0, a = iota + 1, b = iota + 2, a = 1, b = 2
	c, d						// iota = 1, c = iota + 1, d = iota + 2, c = 2, d = 3
    e, f						// iota = 2, e = iota + 1, f = iota + 2, e = 3, f = 4
    g, h = iota * 2, iota * 3	// iota = 3, g = iota * 2, h = iota * 3, g = 6, h = 9
    i, k						// iota = 4, i = iota * 2, k = iota * 3, 1 = 8, k = 12
)

func main () {
	// constant type (read-only)
	const length int = 0
	fmt.Println("length =", length)

	fmt.Println("BEIJING =", BEIJING)
	fmt.Println("SHANGHAI =", SHANGHAI)
	fmt.Println("SHENZHEN =", SHENZHEN)
}
```

### function

```go

func foo1 (a string, b int) int {
	fmt.Println("a =", a)
	fmt.Println("a =", b)

	c := 100

	return c
}

// return multiple variables
func foo2 (a int, b int) (int, int) {
	fmt.Println("a =", a)
	fmt.Println("a =", b)

	return a, b
}

// return multiple variables with name
func foo3 (a int, b int) (r1 int, r2 int) {
	// if we return r1 and r2 right now
	// r1 = 0
	// r2 = 0
	r1 = a
	r2 = b

	return
}

// if r1 and r2 have some type
func foo4 (a int, b int) (r1 , r2 int) {
	// ...
	return
}


func main () {
	c := foo1("abc", 55)
	fmt.Println("c =", c)

	res1, res2 := foo2(1, 2)
	fmt.Println("res1 =", res1)
	fmt.Println("res2 =", res2)

	res1, res2 = foo3(1000, 2000)
	fmt.Println("res1 =", res1)
	fmt.Println("res2 =", res2)
}
```

### import

```go
// 5-init/lib1/lib1.go
// 5-init/lib2/lib2.go
package main

import (
	// with `_`, only call the init() in the lib1
	_ "5-init/lib1"

	// mylib2 "5-init/lib2"
	// . "5-init/lib2"
	"5-init/lib2"

)

func main () {
	//lib1.Lib1Test()

	// mylib2.Lib2Test()
	// Lib2Test()
	lib2.Lib2Test()
}
```

### pointer

```go
func wrong_swap(a int, b int) {
	var temp int
	temp = a
	a = b
	b = temp
}

func true_swap(pa *int, pb *int) {
	var temp int
	temp = *pa
	*pa = *pb
	*pb = temp
}

func main() {
	var a int = 10
	var b int = 20
	wrong_swap(a, b)
	fmt.Println("a =", a, " b =", b) // a = 10  b = 20

	true_swap(&a, &b)
	fmt.Println("a =", a, " b =", b) // a = 20  b = 10

	x := 10
	p := &x                 // p now stores the address of x
	fmt.Println("x =", x)   // 10
	fmt.Println("&x =", &x) // 0x14000122008 (address in memory)
	fmt.Println("p =", p)   // 0x14000122008
}
```

### defer

- `defer` is a key words which will be executed after calling the function
- The function with the `defer` will be pushed into a **stack**.

```go
func main () {
	defer fmt.Println("print finished1")
	defer fmt.Println("print finished2")

	fmt.Println("print 1")
	fmt.Println("print 2")
	/*
	print 1
	print 2
	print finished2
	print finished1
	*/
}
```

In this example:

1. Invoke returnAndDefer()
2. deferFunc() is pushed into a stack
3. Invoke returnFunc() -> "returnFunc called"
4. Pop deferFunc(), invoke deferFunc() -> "deferFunc called"

```go
func returnFunc() int {
	fmt.Println("returnFunc called")
	return 0
}

func deferFunc() int {
	fmt.Println("deferFunc called")
	return 0
}

func returnAndDefer() int {
	defer deferFunc()
	return returnFunc()
}

func main() {
	returnAndDefer()
}
```

### Array

#### Static Array (fixed size)

```go
func printArray(myArray [4]int) {
	for index, value := range myArray {
		fmt.Println("index = ", index, ", value = ", value)
	}

	// Static array: Won't change the value of the myArray3 in the main()
	myArray[0] = 100
}

func main() {
	var myArray1 [10]int
	myArray2 := [10]int{1, 2, 3, 4}
	myArray3 := [4]int{11, 22, 33, 44}

	for i := 0; i < len(myArray1); i++ {
		fmt.Println(myArray1[i])
	}

	for index, value := range myArray2 {
		fmt.Println("index = ", index, ", value = ", value)
	}

	printArray(myArray3)

	fmt.Printf("myArray3 types = %T\n", myArray3) // myArray3 types = [4]int
}

```

#### Dynamic Array

```go
// Actually passed in a pointer
func printArray(myArray []int) {
	for _, value := range myArray {
		fmt.Println("value =", value)
	}

	// Dynamic Array: Will change the value of the myArray in the main()
	myArray[0] = 100
}

func main() {
	// dynamic array
	// Actually a pointer points to the array
	myArray := []int{1, 2, 3, 4}
	printArray(myArray)

	for _, value := range myArray {
		fmt.Println("value =", value)
	}
}

```

### Slice Declaration

```go
func main() {
	// declare slice1 is an array, default values are 1, 2, 3; length = 3
	slice1 := []int{1, 2, 3}

	// declare slice2 is an array, but no space is allocated for slice2
	var slice2 []int
	// Allocate 3 * 8 bytes, default value: 0
	slice2 = make([]int, 3)

	// declare slice3 is an array, allocate 3 * 8 bytes, default value: 0
	var slice3 []int = make([]int, 3)

	// declare slice4 is an array, allocate 3 * 8 bytes, default value: 0
	slice4 := make([]int, 3)

	fmt.Printf("len = %d, slice = %v\n", len(slice1), slice1) // len = 3, slice = [1 2 3]
	fmt.Printf("len = %d, slice = %v\n", len(slice2), slice2) // len = 3, slice = [0 0 0]
	fmt.Printf("len = %d, slice = %v\n", len(slice3), slice3) // len = 3, slice = [0 0 0]
	fmt.Printf("len = %d, slice = %v\n", len(slice4), slice4) // len = 3, slice = [0 0 0]
}
```

### Slice Methods

```go
func main() {
	// 5 is the capacity of the array
	var numbers = make([]int, 3, 5)

	fmt.Printf("len = %d, cap = %d, slice = %v\n", len(numbers), cap(numbers), numbers) // len = 3, cap = 5, slice = [0 0 0]

	// Append a new element to the array, len(numbers) = 4, [0 0 0 1], cap(numbers) = 5
	numbers = append(numbers, 1)
	fmt.Printf("len = %d, cap = %d, slice = %v\n", len(numbers), cap(numbers), numbers)

	// Append a new element to the array, len(numbers) = 5, [0 0 0 1 2], cap(numbers) = 5
	numbers = append(numbers, 2)
	fmt.Printf("len = %d, cap = %d, slice = %v\n", len(numbers), cap(numbers), numbers)

	// Append a new element to the array, len(numbers) = 6, [0 0 0 1 2 3], cap(numbers) = 5 * 2 = 10
	numbers = append(numbers, 3)
	fmt.Printf("len = %d, cap = %d, slice = %v\n", len(numbers), cap(numbers), numbers)

	// [0:2)
	slice1 := numbers[0:2] // here, the pointers of slice1 and numbers points the same array
	fmt.Println(slice1) // [0 0]
	// change the slice1[0] will also change numbers[0]
	slice1[0] = 100

	// copy
	slice2 := make([]int, 3) // [0 0 0]
	copy(slice2, numbers)
	fmt.Println(slice2)
}
```

### map

```go
func main() {
	// Declare myMap1 is a map type, key is string, value is string
	var myMap1 map[string]string
	myMap1 = make(map[string]string, 10)
	myMap1["one"] = "java"
	myMap1["two"] = "c++"
	myMap1["three"] = "python"
	fmt.Println(myMap1)

	// Declare myMap2
	myMap2 := make(map[int]string, 10)
	myMap2[1] = "java"
	myMap2[2] = "c++"
	myMap2[3] = "python"
	fmt.Println(myMap2)

	// Declare myMap3
	myMap3 := map[string]string{
		"one":   "java",
		"two":   "c++",
		"three": "python",
	}
	fmt.Println(myMap3)

	// Delete key-value
	delete(myMap3, "one")
}
```

### struct

```go
type Book struct {
	title string
	auth  string
}

func changeBook(book *Book) {
	book.auth = "Jason" //  Go automatically dereferences struct pointers when accessing fields.
	// Go does not automatically dereference pointers when assigning or reading basic types.
}

func main() {
	var book1 Book
	book1.title = "golang"
	book1.auth = "Larry"
	fmt.Println(book1) // {golang Larry}

	changeBook(&book1)
	fmt.Println(book1) // {golang Larry}
}

```

### class

```go
type Hero struct {
	Name  string
	Ad    int
	Level int
}

func (h Hero) show() {
	fmt.Println("Name =", h.Name)
}

func (h Hero) getName() string {
	return h.Name
}

func (h *Hero) setName(newName string) {
	h.Name = newName
}

func main() {
	hero := Hero{"Larry", 10, 100}
	hero.show()

	// Go automatically converts to (&hero).setName("Jason")
	hero.setName("Jason")
	hero.show()
}

```

### Inheritance

```go
type Human struct {
	name string
	sex  string
}

func (human *Human) Eat() {
	fmt.Println("Human.eat()...")
}

func (human *Human) Walk() {
	fmt.Println("Human.walk()...")
}

type SuperMan struct {
	Human

	level int
}

func (superman *SuperMan) Eat() {
	fmt.Println("SuperMan.Eat()...")
}

func (superman *SuperMan) Fly() {
	fmt.Println("SuperMan.Fly()...")
}

func main() {
	h := Human{"Larry", "female"}
	h.Eat()
	h.Walk()

	s := SuperMan{Human{"Jason", "male"}, 12}
	s.Walk()
	s.Eat()
	s.Fly()
}
```

### interface

```go
// interface is actually a pointer
type AnimalIF interface {
	Sleep()
	GetColor() string
	GetType() string
}

type Cat struct {
	color string
}

func (cat *Cat) Sleep() {
	fmt.Println("Cat is sleeping")
}

func (cat *Cat) GetColor() string {
	return cat.color
}

func (cat *Cat) GetType() string {
	return "Cat"
}

// interface as a type
func showAnimial(animal AnimalIF) {
	animal.Sleep()
	fmt.Println("color = ", animal.GetColor())
	fmt.Println("kind = ", animal.GetType())
}

func main() {
	var animal AnimalIF
	animal = &Cat{"Green"}
	animal.Sleep()

	showAnimial(&Cat{"Red"})
}
```

### type assertion

```go
// interface{} in Golang is like any type in TS
func myFunc(arg interface{}) {
	fmt.Println("myFunc is called...")
	fmt.Println(arg)

	// type assertion
	value, ok := arg.(string)
	if !ok {
		fmt.Println("arg is not string")
	} else {
		fmt.Println("arg is string type, value = ", value)
		fmt.Printf("value type is %T\n", value)
	}
}

type Book struct {
	auth string
}

func main() {
	book := Book{"Golang"}

	myFunc(book)
	myFunc("Hello")
}
```

```go
type Reader interface {
	ReadBook()
}

type Writer interface {
	WriteBook()
}

type Book struct {
}

func (this *Book) ReadBook() {
	fmt.Println("Read a Book")
}
func (this *Book) WriteBook() {
	fmt.Println("Write a Book")
}

func main() {
	b := &Book{}

	var r Reader

	r = b

	r.ReadBook()

	var w Writer
	// r contains a pointer to a Book (*Book) as its concrete value.
	// The compiler checks whether that concrete type (*Book) implements Writer.
	// It does! Because *Book has WriteBook() defined.
	w = r.(Writer)

	w.WriteBook()
}
```

### reflect

```go
import (
	"fmt"
	"reflect"
)

func reflectNum(arg interface{}) {
	fmt.Println("type :", reflect.TypeOf(arg))
	fmt.Println("type :", reflect.ValueOf(arg))
}


type User struct {
	Id   int
	Name string
	Age  int
}

func (user User) Call() {
	fmt.Println("user is called ..")
	fmt.Printf("%v\n", user)
}

func main() {
	var num float64 = 1.23445
	reflectNum(num)

	user := User{1, "Larry", 21}
	DoFiledAndMethod(user)
}

func DoFiledAndMethod(input interface{}) {
	// Get the type of the input
	inputType := reflect.TypeOf(input)
	fmt.Println("inputType is :", inputType.Name())

	// Get the value of input
	inputValue := reflect.ValueOf(input)
	fmt.Println("inputValue is :", inputValue)

	// Get field from the type
	for i := 0; i < inputType.NumField(); i++ {
		field := inputType.Field(i)
		value := inputValue.Field(i).Interface()
		fmt.Printf("%s: %v = %v\n", field.Name, field.Type, value)
	}

	// Get the methods of type
	for i := 0; i < inputType.NumMethod(); i++ {
		m := inputType.Method(i)
		fmt.Printf("%s: %v\n", m.Name, m.Type)
	}
}
/*
type : float64
type : 1.23445
inputType is : User
inputValue is : {1 Larry 21}
Id: int = 1
Name: string = Larry
Age: int = 21
Call: func(main.User)
*/
```

### Tag

```go
import (
	"fmt"
	"reflect"
)

type resume struct {
	Name string `info:"name" doc:"my name"`
	Sex  int    `info:"sex"`
}

func findTag (str interface{}) {
	t := reflect.TypeOf(str).Elem()

	for i := 0; i < t.NumField(); i++ {
		taginfo := t.Field(i).Tag.Get("info")
		tagdoc := t.Field(i).Tag.Get("doc")
		fmt.Println("info: ", taginfo, " tagdoc: ", tagdoc)
		/*
		info:  name  tagdoc:  my name
		info:  sex  tagdoc:
		*/
	}
}

func main() {
	var resume resume

	findTag(&resume)
}
```

### json

```go
import (
	"encoding/json"
	"fmt"
)

type Movie struct {
	Title string   `json:"title"`
	Year  int      `json:"year"`
	Price int      `json:"rmb"`
	Actor []string `json:"actors"`
}

func main() {
	movie := Movie{"moive", 2001, 21, []string{"Larry", "Jason"}}

	// struct -> json
	jsonStr, err := json.Marshal(movie)
	if(err != nil) {
		fmt.Println("json marshal error", err)
		return
	}
	fmt.Printf("jsonStr = %s\n", jsonStr)

	// json -> struct
	myMovie := Movie{}
	err = json.Unmarshal(jsonStr, &myMovie)
	if(err != nil) {
		fmt.Println("json unmarshal error", err)
		return
	}
	fmt.Printf("%v\n", myMovie)
}
```

## Goroutine

### Background

1. Multi-core, scheduled by the operation system scheduler. (cpu1, cpu2, cpu3, cpu4...).
2. kernel threads, handled by the operation system scheduler. (M1, M2, M3).
3. Each kernel thread has a processor (P1, P2, P3).
4. Each p has a local queue, stores goroutines.
5. Goroutine has a global queue, stores goroutines.

### Mechanism

- **Work Stealing**

1. P1 is handling Goroutine1 (G1)
2. P1 has a local queue and it stores G2 and G3
3. P2 is free and nothing in the local queue
4. P2's local queue steals P1's local queue's G3

- **Hand Off**

1. P1 is handling Goroutine1 (G1)
2. P1 has a local queue and it stores G2
3. But G1 is blocking the P1
4. It will invoke another kernel thread (M3) and move the P1 and it's local queue to the M3
5. M1 now binds with G1
6. G1 will sleep or destroyed.

- **GOMAXPROCESS limits the number of processes**

1. Number of CPU cores / 2

- **Seize**

1. co-routine1 binds with a cpu, only when the cpu release the co-routine1, co-routine2 can now bind with the cpu
2. go-routine1 binds with a cpu, after max 10ms, go-routine2 will seize the cpu

- **Global Goroutine Queue**

1. Similar to the work stealing
2. P1 now is handling the G1
3. P1's local queue has no goroutine
4. P2's local queue has no goroutine as well
5. P2's local queue will firstly look the P1's local queue
6. If no goroutine, steals from the Global Goroutine Queue

### Code

```go
import (
	"fmt"
	"time"
)

func newTask() {
	i := 0
	for {
		i++
		fmt.Printf("new Goroutine : i = %d\n", i)
		time.Sleep(1 * time.Second)
	}
}

// main () is a main goroutine
// If main () returns, all the goroutine created by the main() will be destoryed.
func main() {
	// Create a new goroutine
	go newTask()

	i := 0
	for {
		i++
		fmt.Printf("main Goroutine : i = %d\n", i)
		time.Sleep(1 * time.Second)
	}

}
```

```go
import (
	"fmt"
	"runtime"
	"time"
)

func main() {

	// Anonymous function
	go func() {
		defer fmt.Println("A.defer")
		func() {
			defer fmt.Println("B.defer")
			// Exit current goroutine
			runtime.Goexit()
			fmt.Println("B")
		}()
		fmt.Println("A")
	}()
	// endless loop
	for {
		time.Sleep(1 * time.Second)
	}
}
/*
B.defer
A.defer
*/
```

## Channel

- Communicate between two go-routine

```go
func main () {
	c := make(chan int)

	go func () {
		defer fmt.Println("goroutine finished")

		fmt.Println("goroutine is running")

		c <- 225
	}()

	/*
		if num hasn't received the value, main() goroutine will be blocked until receiving
		so main() goroutine will wait after the sub goroutine sends the value to the channel

		same, if main() goroutine is waiting the value, sub goroutine will continue executing
		until sub goroutine send the value to the channel
	*/

	num := <-c

	fmt.Println("num =", num)
	fmt.Println("main goroutine finished ")
}
```

### Unbuffered Channels

1. In step 1, both goroutines reach the channel, but neither begins sending or receiving.

2. In step 2, the left goroutine extends its hand into the channel, simulating a send. At this point, it is locked in the channel until the swap completes.

3. In step 3, the right goroutine extends its hand into the channel, simulating a receive. This goroutine is also locked in the channel until the swap completes.

4. In steps 4 and 5, the swap occurs, and finally, in step 6, both goroutines remove their hands from the channel, simulating the locked goroutines being released. Both goroutines can now proceed with other tasks.

### Buffered Channels

1. In step 1, the right goroutine is receiving a value from the channel.

2. In step 2, the right goroutine independently completes receiving the value, while the left goroutine is sending a new value to the channel.

3. In step 3, the left goroutine is still sending a new value to the channel, while the right goroutine is receiving another value from the channel. These two operations are neither synchronized nor block each other.

4. Finally, in step 4, all sends and receives are complete, and the channel still has several values ​​in it, with room for more.

- When the channel is full, writing data to it will block. When the channel is empty, retrieving data from it will also block.

```go
func main() {
	// buffered channel
	c := make(chan int, 3)

	fmt.Println("len(c) = ", len(c), ", cap(c)", cap(c))

	go func() {
		defer fmt.Println("sub goroutine finished")

		for i := 0; i < 4; i++ {
			c <- i
			fmt.Println("sub goroutine is running, element sent=", i, "len(c)=", len(c), ", cap(c)=", cap(c))
		}
	}()

	time.Sleep(2 * time.Second)

	for i := 0; i < 4; i++ {
		num := <-c
		fmt.Println("num =", num)
	}
	time.Sleep(time.Second)

	fmt.Println("main finished")
}

/*
sub goroutine is running, element sent= 0 len(c)= 1 , cap(c)= 3
sub goroutine is running, element sent= 1 len(c)= 2 , cap(c)= 3
sub goroutine is running, element sent= 2 len(c)= 3 , cap(c)= 3
num = 0
num = 1
num = 2
num = 3
sub goroutine is running, element sent= 3 len(c)= 2 , cap(c)= 3
sub goroutine finished
main finished
*/
```

### Close Channels

- Unlike files, channels don't need to be closed frequently. You should only close a channel when you truly have no more data to send, or when you explicitly want to terminate a range loop.
- After closing a channel, you can no longer send data to it (causing a panic error and causing receive operations to immediately return zero).
- After closing a channel, you can continue to receive data from it.
- For nil channels, both sending and receiving are blocked.

```go
func main() {
	c := make(chan int)

	go func() {
		for i := 0; i < 5; i++ {
			c <- i
		}

		// close key word can close a channel
		close(c)
	}()

	for {
		// ok == true -> channel didnt close
		if data, ok := <-c; ok {
			fmt.Println(data)
		} else {
			break
		}
	}

	fmt.Println("Main Finished..")
}
```

### Range & Channel

```go
func main() {
	c := make(chan int)

	go func() {
		for i := 0; i < 5; i++ {
			c <- i
		}

		// close key word can close a channel
		close(c)
	}()

	for data := range c {
		fmt.Println(data)
	}

	fmt.Println("Main Finished..")
}
```

### Select & Channel

```go
package main

import "fmt"

func fibonacii(c, quit chan int) {
	x, y := 1, 1

	for {
		select {
		// channel c is writable
		case c <- x:
			x = y
			y = x + y

		case <-quit:
			fmt.Println("quit")
			return
		}

	}
}

func main() {
	c := make(chan int)
	quit := make(chan int)

	go func() {
		for i := 0; i < 6; i++ {
			fmt.Println(<-c)
		}

		quit <- 0
	}()

	fibonacii(c, quit)

}

```

## Go Modules

- **go mod init** generates the go.mod file.

- **go mod download** downloads all dependencies specified in the go.mod file.

- **go mod tidy** organizes existing dependencies.

- **go mod graph** displays the existing dependency structure.

- **go mod edit** edits the go.mod file.

- **go mod vendor** exports all project dependencies to the vendor directory.

- **go mod verify** verifies whether a module has been tampered with.

- **go mod wh** displays the reason a module dependency is required.

### GO111MODULE

**Whether to enable go modules mode**

- **Recommendation**: Set to `on` for Go v1.11.2 and later

### GOPROXY

**Third-party dependency download source address for the project**

#### direct

- Used to instruct Go to retrieve module versions from the source address (such as GitHub, etc.)

### GOSUMDB

**Used to verify whether the fetched third-party libraries are complete**

- Default is also an external website
- If GOPROXY is already configured, this doesn't need to be set

### GONOPROXY

**Can be set via GOPRIVATE**

### GONOSUMDB

**Can be set via GOPRIVATE**

### GOPRIVATE

**Can be set via GOPRIVATE**

#### Usage Examples:

**Specify specific private repositories:**

```bash
go env -w GOPRIVATE="git.example.com,github.com/aceld/zinx"
```

- Indicates that `git.example.com` and `github.com/aceld/zinx` are private repositories
- Will not download and verify via GOPROXY

**Wildcard pattern for domain:**

```bash
go env -w GOPRIVATE="*.example.com"
```

- Indicates all subdomains under `example.com`, such as:
  - `git.example.com`
  - `hello.example.com`
- Will not download and verify via GOPROXY

#### Setting Environment Variables

**View environment variables via go env:**

```bash
go env -w GO111MODULE=on
```

## Go Modules Initialization and Usage Guide

### Step 1: Enable Go Modules Mode

#### Ensure GO111MODULE=on

```bash
go env -w GO111MODULE=on
```

or

```bash
export GO111MODULE=on
```

**Set in user startup script:**
Need to add the startup script to source `~/.bashrc`

---

#### Using Go Modules to Initialize a Project

#### Create a project in any directory (not required to be in $GOPATH/src)

```bash
mkdir -p $HOME/aceld/modules_test
```

#### Create go.mod file and configure the project's module name

```bash
go mod init github.com/aceld/module_test
```

**This will generate a go.mod file:**

```mod
module github.com/aceld/modules_test

go 1.14
```

---

### Step 2: Initialize the Project

#### The go.mod file will add a new line of code

**If source code depends on certain packages (e.g., github.com/aceld/zinx/znet):**

#### Download dependencies in the project directory:

**Manual download:**

```bash
go get github.com/aceld/zinx/znet
```

**Automatic download:**

```mod
module github.com/aceld/moudies_test

go 1.14

require github.com/aceld/zinx v0.0.0-20200315073925-f09df55dc746 // indirect
```

**Meaning of the module dependency:**

- Indicates the current module depends on `github.com/aceld/zinx`
- Dependency version: `v0.0.0-20200315073925-f09df55dc746`

#### //indirect

**Indicates an indirect dependency**

- The project directly depends on the znet package
- All previously depended packages are now included

**Example dependency chains:**

- `github.com/aceld/zinx v0.0.0-20200315073925-f09df55dc746 h1:TurbcEfboY81jsVSKqk8FN8i`
- `github.com/aceld/zinx v0.0.0-20200315073925-f09df55dc746/go.mod h1:bMiERrPdR8FzpZqh`
- `github.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=`

---

#### A go.sum file will be generated

#### Purpose of go.sum file:

Lists all direct or indirect dependencies the current project has on the module versions to ensure the module versions remain consistent after the project's dependencies won't change

#### h1:hash

**Indicates the entire zip file of the project and the checksum hash generated after decompression of all files**

- If it doesn't exist, it may indicate the dependency library could be unavailable

#### xxx/go.mod h1:hash

**The checksum of the go.mod file**

---

```go

```

```go

```

```go

```

```go

```

```go

```

```go

```
