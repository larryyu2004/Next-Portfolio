# Golang

## Syntax

### Import Package

```go
package main
```

### Import

```go
import "fmt"
import "time"
```

or

```go
import (
	"fmt"
	"time"
)
```

### main function

```go
func main () { // The { must be on the same line of the function (google style)
	// This is single line comment

	/*
	this is
	a multiline
	comment!
	*/

	time.Sleep(1 * time.Second) // The ; is optional (like JS and TS)
	fmt.Println("Hello World")

}
```

### declare variables

```go
func main () {
	// 1. declare a variable, default value is 0
	var a int
	fmt.Println("a =", a) // b = 2
	fmt.Printf("type of a = %T\n", a) // type of a = int

	// 2. declare a variable, initialise the value
	var b int = 2
	fmt.Println("b =", b) // b = 2
	fmt.Printf("type of b = %T\n", b) // type of b = int

	// 3. Omit the data type
	var c = 3
	fmt.Println("c =", c) // c = 3
	fmt.Printf("type of c = %T\n", c) // type of c = int

	// 4. Omit var, auto match
	// := can only be used in the function block
	d := 3
	fmt.Println("d =", d) // d = 3
	fmt.Printf("type of d = %T\n", d) // type of d = int

	// declare multiple variables
	var xx, yy int = 100, 200
	fmt.Println("xx =", xx, "yy =", yy)

	var (
		vv int = 100
		jj bool = true
	)
	fmt.Println("vv =", vv, "jj =", jj)
}
```

### const

```go
const (
	// Adding a 'iota' in the const(), iota will increase 1 by each line. iota in the first line is 0
	BEIJING = iota  // iota = 0
	SHANGHAI		// iota = 1
	SHENZHEN		// iota = 2
)

const (
    a, b = iota + 1, iota + 2	// iota = 0, a = iota + 1, b = iota + 2, a = 1, b = 2
	c, d						// iota = 1, c = iota + 1, d = iota + 2, c = 2, d = 3
    e, f						// iota = 2, e = iota + 1, f = iota + 2, e = 3, f = 4
    g, h = iota * 2, iota * 3	// iota = 3, g = iota * 2, h = iota * 3, g = 6, h = 9
    i, k						// iota = 4, i = iota * 2, k = iota * 3, 1 = 8, k = 12
)

func main () {
	// constant type (read-only)
	const length int = 0
	fmt.Println("length =", length)

	fmt.Println("BEIJING =", BEIJING)
	fmt.Println("SHANGHAI =", SHANGHAI)
	fmt.Println("SHENZHEN =", SHENZHEN)
}
```

### function

```go

func foo1 (a string, b int) int {
	fmt.Println("a =", a)
	fmt.Println("a =", b)

	c := 100

	return c
}

// return multiple variables
func foo2 (a int, b int) (int, int) {
	fmt.Println("a =", a)
	fmt.Println("a =", b)

	return a, b
}

// return multiple variables with name
func foo3 (a int, b int) (r1 int, r2 int) {
	// if we return r1 and r2 right now
	// r1 = 0
	// r2 = 0
	r1 = a
	r2 = b

	return
}

// if r1 and r2 have some type
func foo4 (a int, b int) (r1 , r2 int) {
	// ...
	return
}


func main () {
	c := foo1("abc", 55)
	fmt.Println("c =", c)

	res1, res2 := foo2(1, 2)
	fmt.Println("res1 =", res1)
	fmt.Println("res2 =", res2)

	res1, res2 = foo3(1000, 2000)
	fmt.Println("res1 =", res1)
	fmt.Println("res2 =", res2)
}
```

### import

```go
// 5-init/lib1/lib1.go
// 5-init/lib2/lib2.go
package main

import (
	// with `_`, only call the init() in the lib1
	_ "5-init/lib1"

	// mylib2 "5-init/lib2"
	// . "5-init/lib2"
	"5-init/lib2"

)

func main () {
	//lib1.Lib1Test()

	// mylib2.Lib2Test()
	// Lib2Test()
	lib2.Lib2Test()
}
```

### pointer

```go
func wrong_swap(a int, b int) {
	var temp int
	temp = a
	a = b
	b = temp
}

func true_swap(pa *int, pb *int) {
	var temp int
	temp = *pa
	*pa = *pb
	*pb = temp
}

func main() {
	var a int = 10
	var b int = 20
	wrong_swap(a, b)
	fmt.Println("a =", a, " b =", b) // a = 10  b = 20

	true_swap(&a, &b)
	fmt.Println("a =", a, " b =", b) // a = 20  b = 10

	x := 10
	p := &x                 // p now stores the address of x
	fmt.Println("x =", x)   // 10
	fmt.Println("&x =", &x) // 0x14000122008 (address in memory)
	fmt.Println("p =", p)   // 0x14000122008
}
```

### defer

- `defer` is a key words which will be executed after calling the function
- The function with the `defer` will be pushed into a **stack**.

```go
func main () {
	defer fmt.Println("print finished1")
	defer fmt.Println("print finished2")

	fmt.Println("print 1")
	fmt.Println("print 2")
	/*
	print 1
	print 2
	print finished2
	print finished1
	*/
}
```

In this example:

1. Invoke returnAndDefer()
2. deferFunc() is pushed into a stack
3. Invoke returnFunc() -> "returnFunc called"
4. Pop deferFunc(), invoke deferFunc() -> "deferFunc called"

```go
func returnFunc() int {
	fmt.Println("returnFunc called")
	return 0
}

func deferFunc() int {
	fmt.Println("deferFunc called")
	return 0
}

func returnAndDefer() int {
	defer deferFunc()
	return returnFunc()
}

func main() {
	returnAndDefer()
}
```

### Array

#### Static Array (fixed size)

```go
func printArray(myArray [4]int) {
	for index, value := range myArray {
		fmt.Println("index = ", index, ", value = ", value)
	}

	// Static array: Won't change the value of the myArray3 in the main()
	myArray[0] = 100
}

func main() {
	var myArray1 [10]int
	myArray2 := [10]int{1, 2, 3, 4}
	myArray3 := [4]int{11, 22, 33, 44}

	for i := 0; i < len(myArray1); i++ {
		fmt.Println(myArray1[i])
	}

	for index, value := range myArray2 {
		fmt.Println("index = ", index, ", value = ", value)
	}

	printArray(myArray3)

	fmt.Printf("myArray3 types = %T\n", myArray3) // myArray3 types = [4]int
}

```

#### Dynamic Array

```go
// Actually passed in a pointer
func printArray(myArray []int) {
	for _, value := range myArray {
		fmt.Println("value =", value)
	}

	// Dynamic Array: Will change the value of the myArray in the main()
	myArray[0] = 100
}

func main() {
	// dynamic array
	// Actually a pointer points to the array
	myArray := []int{1, 2, 3, 4}
	printArray(myArray)

	for _, value := range myArray {
		fmt.Println("value =", value)
	}
}

```

### Slice Declaration

```go
func main() {
	// declare slice1 is an array, default values are 1, 2, 3; length = 3
	slice1 := []int{1, 2, 3}

	// declare slice2 is an array, but no space is allocated for slice2
	var slice2 []int
	// Allocate 3 * 8 bytes, default value: 0
	slice2 = make([]int, 3)

	// declare slice3 is an array, allocate 3 * 8 bytes, default value: 0
	var slice3 []int = make([]int, 3)

	// declare slice4 is an array, allocate 3 * 8 bytes, default value: 0
	slice4 := make([]int, 3)

	fmt.Printf("len = %d, slice = %v\n", len(slice1), slice1) // len = 3, slice = [1 2 3]
	fmt.Printf("len = %d, slice = %v\n", len(slice2), slice2) // len = 3, slice = [0 0 0]
	fmt.Printf("len = %d, slice = %v\n", len(slice3), slice3) // len = 3, slice = [0 0 0]
	fmt.Printf("len = %d, slice = %v\n", len(slice4), slice4) // len = 3, slice = [0 0 0]
}
```

### Slice Methods

```go
func main() {
	// 5 is the capacity of the array
	var numbers = make([]int, 3, 5)

	fmt.Printf("len = %d, cap = %d, slice = %v\n", len(numbers), cap(numbers), numbers) // len = 3, cap = 5, slice = [0 0 0]

	// Append a new element to the array, len(numbers) = 4, [0 0 0 1], cap(numbers) = 5
	numbers = append(numbers, 1)
	fmt.Printf("len = %d, cap = %d, slice = %v\n", len(numbers), cap(numbers), numbers)

	// Append a new element to the array, len(numbers) = 5, [0 0 0 1 2], cap(numbers) = 5
	numbers = append(numbers, 2)
	fmt.Printf("len = %d, cap = %d, slice = %v\n", len(numbers), cap(numbers), numbers)

	// Append a new element to the array, len(numbers) = 6, [0 0 0 1 2 3], cap(numbers) = 5 * 2 = 10
	numbers = append(numbers, 3)
	fmt.Printf("len = %d, cap = %d, slice = %v\n", len(numbers), cap(numbers), numbers)

	// [0:2)
	slice1 := numbers[0:2] // here, the pointers of slice1 and numbers points the same array
	fmt.Println(slice1) // [0 0]
	// change the slice1[0] will also change numbers[0]
	slice1[0] = 100

	// copy
	slice2 := make([]int, 3) // [0 0 0]
	copy(slice2, numbers)
	fmt.Println(slice2)
}
```

### map

```go
func main() {
	// Declare myMap1 is a map type, key is string, value is string
	var myMap1 map[string]string
	myMap1 = make(map[string]string, 10)
	myMap1["one"] = "java"
	myMap1["two"] = "c++"
	myMap1["three"] = "python"
	fmt.Println(myMap1)

	// Declare myMap2
	myMap2 := make(map[int]string, 10)
	myMap2[1] = "java"
	myMap2[2] = "c++"
	myMap2[3] = "python"
	fmt.Println(myMap2)

	// Declare myMap3
	myMap3 := map[string]string{
		"one":   "java",
		"two":   "c++",
		"three": "python",
	}
	fmt.Println(myMap3)

	// Delete key-value
	delete(myMap3, "one")
}
```

### struct

```go
type Book struct {
	title string
	auth  string
}

func changeBook(book *Book) {
	book.auth = "Jason" //  Go automatically dereferences struct pointers when accessing fields.
	// Go does not automatically dereference pointers when assigning or reading basic types.
}

func main() {
	var book1 Book
	book1.title = "golang"
	book1.auth = "Larry"
	fmt.Println(book1) // {golang Larry}

	changeBook(&book1)
	fmt.Println(book1) // {golang Larry}
}

```

### class

```go
type Hero struct {
	Name  string
	Ad    int
	Level int
}

func (h Hero) show() {
	fmt.Println("Name =", h.Name)
}

func (h Hero) getName() string {
	return h.Name
}

func (h *Hero) setName(newName string) {
	h.Name = newName
}

func main() {
	hero := Hero{"Larry", 10, 100}
	hero.show()

	// Go automatically converts to (&hero).setName("Jason")
	hero.setName("Jason")
	hero.show()
}

```

### Inheritance

```go
type Human struct {
	name string
	sex  string
}

func (human *Human) Eat() {
	fmt.Println("Human.eat()...")
}

func (human *Human) Walk() {
	fmt.Println("Human.walk()...")
}

type SuperMan struct {
	Human

	level int
}

func (superman *SuperMan) Eat() {
	fmt.Println("SuperMan.Eat()...")
}

func (superman *SuperMan) Fly() {
	fmt.Println("SuperMan.Fly()...")
}

func main() {
	h := Human{"Larry", "female"}
	h.Eat()
	h.Walk()

	s := SuperMan{Human{"Jason", "male"}, 12}
	s.Walk()
	s.Eat()
	s.Fly()
}
```

### interface

```go
// interface is actually a pointer
type AnimalIF interface {
	Sleep()
	GetColor() string
	GetType() string
}

type Cat struct {
	color string
}

func (cat *Cat) Sleep() {
	fmt.Println("Cat is sleeping")
}

func (cat *Cat) GetColor() string {
	return cat.color
}

func (cat *Cat) GetType() string {
	return "Cat"
}

// interface as a type
func showAnimial(animal AnimalIF) {
	animal.Sleep()
	fmt.Println("color = ", animal.GetColor())
	fmt.Println("kind = ", animal.GetType())
}

func main() {
	var animal AnimalIF
	animal = &Cat{"Green"}
	animal.Sleep()

	showAnimial(&Cat{"Red"})
}
```

### type assertion

```go
// interface{} in Golang is like any type in TS
func myFunc(arg interface{}) {
	fmt.Println("myFunc is called...")
	fmt.Println(arg)

	// type assertion
	value, ok := arg.(string)
	if !ok {
		fmt.Println("arg is not string")
	} else {
		fmt.Println("arg is string type, value = ", value)
		fmt.Printf("value type is %T\n", value)
	}
}

type Book struct {
	auth string
}

func main() {
	book := Book{"Golang"}

	myFunc(book)
	myFunc("Hello")
}
```

```go
type Reader interface {
	ReadBook()
}

type Writer interface {
	WriteBook()
}

type Book struct {
}

func (this *Book) ReadBook() {
	fmt.Println("Read a Book")
}
func (this *Book) WriteBook() {
	fmt.Println("Write a Book")
}

func main() {
	b := &Book{}

	var r Reader

	r = b

	r.ReadBook()

	var w Writer
	// r contains a pointer to a Book (*Book) as its concrete value.
	// The compiler checks whether that concrete type (*Book) implements Writer.
	// It does! Because *Book has WriteBook() defined.
	w = r.(Writer)

	w.WriteBook()
}
```

### reflect

```go
import (
	"fmt"
	"reflect"
)

func reflectNum(arg interface{}) {
	fmt.Println("type :", reflect.TypeOf(arg))
	fmt.Println("type :", reflect.ValueOf(arg))
}


type User struct {
	Id   int
	Name string
	Age  int
}

func (user User) Call() {
	fmt.Println("user is called ..")
	fmt.Printf("%v\n", user)
}

func main() {
	var num float64 = 1.23445
	reflectNum(num)

	user := User{1, "Larry", 21}
	DoFiledAndMethod(user)
}

func DoFiledAndMethod(input interface{}) {
	// Get the type of the input
	inputType := reflect.TypeOf(input)
	fmt.Println("inputType is :", inputType.Name())

	// Get the value of input
	inputValue := reflect.ValueOf(input)
	fmt.Println("inputValue is :", inputValue)

	// Get field from the type
	for i := 0; i < inputType.NumField(); i++ {
		field := inputType.Field(i)
		value := inputValue.Field(i).Interface()
		fmt.Printf("%s: %v = %v\n", field.Name, field.Type, value)
	}

	// Get the methods of type
	for i := 0; i < inputType.NumMethod(); i++ {
		m := inputType.Method(i)
		fmt.Printf("%s: %v\n", m.Name, m.Type)
	}
}
/*
type : float64
type : 1.23445
inputType is : User
inputValue is : {1 Larry 21}
Id: int = 1
Name: string = Larry
Age: int = 21
Call: func(main.User)
*/
```

### Tag

```go
import (
	"fmt"
	"reflect"
)

type resume struct {
	Name string `info:"name" doc:"my name"`
	Sex  int    `info:"sex"`
}

func findTag (str interface{}) {
	t := reflect.TypeOf(str).Elem()

	for i := 0; i < t.NumField(); i++ {
		taginfo := t.Field(i).Tag.Get("info")
		tagdoc := t.Field(i).Tag.Get("doc")
		fmt.Println("info: ", taginfo, " tagdoc: ", tagdoc)
		/*
		info:  name  tagdoc:  my name
		info:  sex  tagdoc:
		*/
	}
}

func main() {
	var resume resume

	findTag(&resume)
}
```

### json

```go
import (
	"encoding/json"
	"fmt"
)

type Movie struct {
	Title string   `json:"title"`
	Year  int      `json:"year"`
	Price int      `json:"rmb"`
	Actor []string `json:"actors"`
}

func main() {
	movie := Movie{"moive", 2001, 21, []string{"Larry", "Jason"}}

	// struct -> json
	jsonStr, err := json.Marshal(movie)
	if(err != nil) {
		fmt.Println("json marshal error", err)
		return
	}
	fmt.Printf("jsonStr = %s\n", jsonStr)

	// json -> struct
	myMovie := Movie{}
	err = json.Unmarshal(jsonStr, &myMovie)
	if(err != nil) {
		fmt.Println("json unmarshal error", err)
		return
	}
	fmt.Printf("%v\n", myMovie)
}
```

## Goroutine

### Background

1. Multi-core, scheduled by the operation system scheduler. (cpu1, cpu2, cpu3, cpu4...).
2. kernel threads, handled by the operation system scheduler. (M1, M2, M3).
3. Each kernel thread has a processor (P1, P2, P3).
4. Each p has a local queue, stores goroutines.
5. Goroutine has a global queue, stores goroutines.

### Mechanism

- **Work Stealing**

1. P1 is handling Goroutine1 (G1)
2. P1 has a local queue and it stores G2 and G3
3. P1 is free and nothing in the local queue
4. P1's local queue steals P1's local queue's G3

- **Hand Off**

1. P1 is handling Goroutine1 (G1)
2. P1 has a local queue and it stores G2
3. But G1 is blocking the P1
4. It will invoke another kernel thread (M3) and move the P0 and it's local queue to the M3
5. M1 now binds with G1
6. G1 will sleep or destroyed.

- **GOMAXPROCESS limits the number of processes**
1. Number of CPU cores / 2

- **Seize**
1. co-routine1 binds with a cpu, only when the cpu release the co-routine1, co-routine2 can now bind with the cpu
2. go-routine1 binds with a cpu, after max 10ms, go-routine2 will seize the cpu

- **Global Goroutine Queue**
1. Similar to the work stealing
2. P1 now is handling the G1
3. P1's local queue has no goroutine
4. P2's local queue has no goroutine as well
5. P2's local queue will firstly look the P1's local queue
6. If no goroutine, steals from the Global Goroutine Queue

### Code
```go
import (
	"fmt"
	"time"
)

func newTask() {
	i := 0
	for {
		i++
		fmt.Printf("new Goroutine : i = %d\n", i)
		time.Sleep(1 * time.Second)
	}
}

// main () is a main goroutine
// If main () returns, all the goroutine created by the main() will be destoryed.
func main() {
	// Create a new goroutine
	go newTask()
	
	i := 0
	for {
		i++
		fmt.Printf("main Goroutine : i = %d\n", i)
		time.Sleep(1 * time.Second)
	}
	
}
```

```go
import (
	"fmt"
	"runtime"
	"time"
)

func main() {

	// Anonymous function
	go func() {
		defer fmt.Println("A.defer")
		func() {
			defer fmt.Println("B.defer")
			// Exit current goroutine
			runtime.Goexit()
			fmt.Println("B")
		}()
		fmt.Println("A")
	}()
	// endless loop
	for {
		time.Sleep(1 * time.Second)
	}
}
/*
B.defer
A.defer
*/
```

## Channel
- Communicate between two go-routine

```go
func main () {
	c := make(chan int)

	go func () {
		defer fmt.Println("goroutine finished")

		fmt.Println("goroutine is running")

		c <- 225
	}()
	
	/*
		if num hasn't received the value, main() goroutine will be blocked until receiving
		so main() goroutine will wait after the sub goroutine sends the value to the channel

		same, if main() goroutine is waiting the value, sub goroutine will continue executing
		until sub goroutine send the value to the channel
	*/

	num := <-c

	fmt.Println("num =", num)
	fmt.Println("main goroutine finished ")
}
```

### Unbuffered Channels
1. In step 1, both goroutines reach the channel, but neither begins sending or receiving.

2. In step 2, the left goroutine extends its hand into the channel, simulating a send. At this point, it is locked in the channel until the swap completes.

3. In step 3, the right goroutine extends its hand into the channel, simulating a receive. This goroutine is also locked in the channel until the swap completes.

4. In steps 4 and 5, the swap occurs, and finally, in step 6, both goroutines remove their hands from the channel, simulating the locked goroutines being released. Both goroutines can now proceed with other tasks.

### Buffered Channels
1. In step 1, the right goroutine is receiving a value from the channel.

2. In step 2, the right goroutine independently completes receiving the value, while the left goroutine is sending a new value to the channel.

3. In step 3, the left goroutine is still sending a new value to the channel, while the right goroutine is receiving another value from the channel. These two operations are neither synchronized nor block each other.

4. Finally, in step 4, all sends and receives are complete, and the channel still has several values ​​in it, with room for more.

- When the channel is full, writing data to it will block. When the channel is empty, retrieving data from it will also block.

```go
func main() {
	// buffered channel
	c := make(chan int, 3)

	fmt.Println("len(c) = ", len(c), ", cap(c)", cap(c))

	go func() {
		defer fmt.Println("sub goroutine finished")

		for i := 0; i < 4; i++ {
			c <- i
			fmt.Println("sub goroutine is running, element sent=", i, "len(c)=", len(c), ", cap(c)=", cap(c))
		}
	}()

	time.Sleep(2 * time.Second)

	for i := 0; i < 4; i++ {
		num := <-c
		fmt.Println("num =", num)
	}
	time.Sleep(time.Second)
	
	fmt.Println("main finished")
}

/*
sub goroutine is running, element sent= 0 len(c)= 1 , cap(c)= 3
sub goroutine is running, element sent= 1 len(c)= 2 , cap(c)= 3
sub goroutine is running, element sent= 2 len(c)= 3 , cap(c)= 3
num = 0
num = 1
num = 2
num = 3
sub goroutine is running, element sent= 3 len(c)= 2 , cap(c)= 3
sub goroutine finished
main finished
*/
```

```go
```

```go
```

```go
```

```go
```