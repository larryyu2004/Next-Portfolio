# Golang

## Basic

### Import Package

```go
package main
```

### Import

```go
import "fmt"
import "time"
```

or

```go
import (
	"fmt"
	"time"
)
```

### main function

```go
func main () { // The { must be on the same line of the function (google style)
	// This is single line comment

	/*
	this is
	a multiline
	comment!
	*/

	time.Sleep(1 * time.Second) // The ; is optional (like JS and TS)
	fmt.Println("Hello World")

}
```

### Declear variables

```go
func main () {
	// 1. Declear a variable, default value is 0
	var a int
	fmt.Println("a =", a) // b = 2
	fmt.Printf("type of a = %T\n", a) // type of a = int

	// 2. Declear a variable, initialise the value
	var b int = 2
	fmt.Println("b =", b) // b = 2
	fmt.Printf("type of b = %T\n", b) // type of b = int

	// 3. Omit the data type
	var c = 3
	fmt.Println("c =", c) // c = 3
	fmt.Printf("type of c = %T\n", c) // type of c = int

	// 4. Omit var, auto match
	// := can only be used in the function block
	d := 3
	fmt.Println("d =", d) // d = 3
	fmt.Printf("type of d = %T\n", d) // type of d = int

	// Declear multiple variables
	var xx, yy int = 100, 200
	fmt.Println("xx =", xx, "yy =", yy)

	var (
		vv int = 100
		jj bool = true
	)
	fmt.Println("vv =", vv, "jj =", jj)
}
```

### const

```go
const (
	// Adding a 'iota' in the const(), iota will increase 1 by each line. iota in the first line is 0
	BEIJING = iota  // iota = 0
	SHANGHAI		// iota = 1
	SHENZHEN		// iota = 2
)

const (
    a, b = iota + 1, iota + 2	// iota = 0, a = iota + 1, b = iota + 2, a = 1, b = 2
	c, d						// iota = 1, c = iota + 1, d = iota + 2, c = 2, d = 3
    e, f						// iota = 2, e = iota + 1, f = iota + 2, e = 3, f = 4
    g, h = iota * 2, iota * 3	// iota = 3, g = iota * 2, h = iota * 3, g = 6, h = 9
    i, k						// iota = 4, i = iota * 2, k = iota * 3, 1 = 8, k = 12
)

func main () {
	// constant type (read-only)
	const length int = 0
	fmt.Println("length =", length)

	fmt.Println("BEIJING =", BEIJING)
	fmt.Println("SHANGHAI =", SHANGHAI)
	fmt.Println("SHENZHEN =", SHENZHEN)
}
```

### function

```go

func foo1 (a string, b int) int {
	fmt.Println("a =", a)
	fmt.Println("a =", b)

	c := 100

	return c
}

// return multiple variables
func foo2 (a int, b int) (int, int) {
	fmt.Println("a =", a)
	fmt.Println("a =", b)

	return a, b
}

// return multiple variables with name
func foo3 (a int, b int) (r1 int, r2 int) {
	// if we return r1 and r2 right now
	// r1 = 0
	// r2 = 0
	r1 = a
	r2 = b

	return
}

// if r1 and r2 have some type
func foo4 (a int, b int) (r1 , r2 int) {
	// ...
	return
}


func main () {
	c := foo1("abc", 55)
	fmt.Println("c =", c)

	res1, res2 := foo2(1, 2)
	fmt.Println("res1 =", res1)
	fmt.Println("res2 =", res2)

	res1, res2 = foo3(1000, 2000)
	fmt.Println("res1 =", res1)
	fmt.Println("res2 =", res2)
}
```

### import

```go
// 5-init/lib1/lib1.go
// 5-init/lib2/lib2.go
package main

import (
	// with `_`, only call the init() in the lib1
	_ "5-init/lib1"

	// mylib2 "5-init/lib2"
	// . "5-init/lib2"
	"5-init/lib2"

)

func main () {
	//lib1.Lib1Test()

	// mylib2.Lib2Test()
	// Lib2Test()
	lib2.Lib2Test()
}
```

### pointer

```go
func wrong_swap(a int, b int) {
	var temp int
	temp = a
	a = b
	b = temp
}

func true_swap(pa *int, pb *int) {
	var temp int
	temp = *pa
	*pa = *pb
	*pb = temp
}

func main() {
	var a int = 10
	var b int = 20
	wrong_swap(a, b)
	fmt.Println("a =", a, " b =", b) // a = 10  b = 20

	true_swap(&a, &b)
	fmt.Println("a =", a, " b =", b) // a = 20  b = 10

	x := 10
	p := &x                 // p now stores the address of x
	fmt.Println("x =", x)   // 10
	fmt.Println("&x =", &x) // 0x14000122008 (address in memory)
	fmt.Println("p =", p)   // 0x14000122008
}
```

### defer

- `defer` is a key words which will be executed after calling the function
- The function with the `defer` will be pushed into a **stack**.

```go
func main () {
	defer fmt.Println("print finished1")
	defer fmt.Println("print finished2")

	fmt.Println("print 1")
	fmt.Println("print 2")
	/*
	print 1
	print 2
	print finished2
	print finished1
	*/
}
```

In this example:

1. Invoke returnAndDefer()
2. deferFunc() is pushed into a stack
3. Invoke returnFunc() -> "returnFunc called"
4. Pop deferFunc(), invoke deferFunc() -> "deferFunc called"

```go
func returnFunc() int {
	fmt.Println("returnFunc called")
	return 0
}

func deferFunc() int {
	fmt.Println("deferFunc called")
	return 0
}

func returnAndDefer() int {
	defer deferFunc()
	return returnFunc()
}

func main() {
	returnAndDefer()
}
```
