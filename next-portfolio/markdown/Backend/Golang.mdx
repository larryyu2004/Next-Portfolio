# Golang

## Syntax

### Import Package

```go
package main
```

### Import

```go
import "fmt"
import "time"
```

or

```go
import (
	"fmt"
	"time"
)
```

### main function

```go
func main () { // The { must be on the same line of the function (google style)
	// This is single line comment

	/*
	this is
	a multiline
	comment!
	*/

	time.Sleep(1 * time.Second) // The ; is optional (like JS and TS)
	fmt.Println("Hello World")

}
```

### declare variables

```go
func main () {
	// 1. declare a variable, default value is 0
	var a int
	fmt.Println("a =", a) // b = 2
	fmt.Printf("type of a = %T\n", a) // type of a = int

	// 2. declare a variable, initialise the value
	var b int = 2
	fmt.Println("b =", b) // b = 2
	fmt.Printf("type of b = %T\n", b) // type of b = int

	// 3. Omit the data type
	var c = 3
	fmt.Println("c =", c) // c = 3
	fmt.Printf("type of c = %T\n", c) // type of c = int

	// 4. Omit var, auto match
	// := can only be used in the function block
	d := 3
	fmt.Println("d =", d) // d = 3
	fmt.Printf("type of d = %T\n", d) // type of d = int

	// declare multiple variables
	var xx, yy int = 100, 200
	fmt.Println("xx =", xx, "yy =", yy)

	var (
		vv int = 100
		jj bool = true
	)
	fmt.Println("vv =", vv, "jj =", jj)
}
```

### const

```go
const (
	// Adding a 'iota' in the const(), iota will increase 1 by each line. iota in the first line is 0
	BEIJING = iota  // iota = 0
	SHANGHAI		// iota = 1
	SHENZHEN		// iota = 2
)

const (
    a, b = iota + 1, iota + 2	// iota = 0, a = iota + 1, b = iota + 2, a = 1, b = 2
	c, d						// iota = 1, c = iota + 1, d = iota + 2, c = 2, d = 3
    e, f						// iota = 2, e = iota + 1, f = iota + 2, e = 3, f = 4
    g, h = iota * 2, iota * 3	// iota = 3, g = iota * 2, h = iota * 3, g = 6, h = 9
    i, k						// iota = 4, i = iota * 2, k = iota * 3, 1 = 8, k = 12
)

func main () {
	// constant type (read-only)
	const length int = 0
	fmt.Println("length =", length)

	fmt.Println("BEIJING =", BEIJING)
	fmt.Println("SHANGHAI =", SHANGHAI)
	fmt.Println("SHENZHEN =", SHENZHEN)
}
```

### function

```go

func foo1 (a string, b int) int {
	fmt.Println("a =", a)
	fmt.Println("a =", b)

	c := 100

	return c
}

// return multiple variables
func foo2 (a int, b int) (int, int) {
	fmt.Println("a =", a)
	fmt.Println("a =", b)

	return a, b
}

// return multiple variables with name
func foo3 (a int, b int) (r1 int, r2 int) {
	// if we return r1 and r2 right now
	// r1 = 0
	// r2 = 0
	r1 = a
	r2 = b

	return
}

// if r1 and r2 have some type
func foo4 (a int, b int) (r1 , r2 int) {
	// ...
	return
}


func main () {
	c := foo1("abc", 55)
	fmt.Println("c =", c)

	res1, res2 := foo2(1, 2)
	fmt.Println("res1 =", res1)
	fmt.Println("res2 =", res2)

	res1, res2 = foo3(1000, 2000)
	fmt.Println("res1 =", res1)
	fmt.Println("res2 =", res2)
}
```

### import

```go
// 5-init/lib1/lib1.go
// 5-init/lib2/lib2.go
package main

import (
	// with `_`, only call the init() in the lib1
	_ "5-init/lib1"

	// mylib2 "5-init/lib2"
	// . "5-init/lib2"
	"5-init/lib2"

)

func main () {
	//lib1.Lib1Test()

	// mylib2.Lib2Test()
	// Lib2Test()
	lib2.Lib2Test()
}
```

### pointer

```go
func wrong_swap(a int, b int) {
	var temp int
	temp = a
	a = b
	b = temp
}

func true_swap(pa *int, pb *int) {
	var temp int
	temp = *pa
	*pa = *pb
	*pb = temp
}

func main() {
	var a int = 10
	var b int = 20
	wrong_swap(a, b)
	fmt.Println("a =", a, " b =", b) // a = 10  b = 20

	true_swap(&a, &b)
	fmt.Println("a =", a, " b =", b) // a = 20  b = 10

	x := 10
	p := &x                 // p now stores the address of x
	fmt.Println("x =", x)   // 10
	fmt.Println("&x =", &x) // 0x14000122008 (address in memory)
	fmt.Println("p =", p)   // 0x14000122008
}
```

### defer

- `defer` is a key words which will be executed after calling the function
- The function with the `defer` will be pushed into a **stack**.

```go
func main () {
	defer fmt.Println("print finished1")
	defer fmt.Println("print finished2")

	fmt.Println("print 1")
	fmt.Println("print 2")
	/*
	print 1
	print 2
	print finished2
	print finished1
	*/
}
```

In this example:

1. Invoke returnAndDefer()
2. deferFunc() is pushed into a stack
3. Invoke returnFunc() -> "returnFunc called"
4. Pop deferFunc(), invoke deferFunc() -> "deferFunc called"

```go
func returnFunc() int {
	fmt.Println("returnFunc called")
	return 0
}

func deferFunc() int {
	fmt.Println("deferFunc called")
	return 0
}

func returnAndDefer() int {
	defer deferFunc()
	return returnFunc()
}

func main() {
	returnAndDefer()
}
```

### Array

#### Static Array (fixed size)

```go
func printArray(myArray [4]int) {
	for index, value := range myArray {
		fmt.Println("index = ", index, ", value = ", value)
	}

	// Static array: Won't change the value of the myArray3 in the main()
	myArray[0] = 100
}

func main() {
	var myArray1 [10]int
	myArray2 := [10]int{1, 2, 3, 4}
	myArray3 := [4]int{11, 22, 33, 44}

	for i := 0; i < len(myArray1); i++ {
		fmt.Println(myArray1[i])
	}

	for index, value := range myArray2 {
		fmt.Println("index = ", index, ", value = ", value)
	}

	printArray(myArray3)

	fmt.Printf("myArray3 types = %T\n", myArray3) // myArray3 types = [4]int
}

```

#### Dynamic Array

```go
// Actually passed in a pointer
func printArray(myArray []int) {
	for _, value := range myArray {
		fmt.Println("value =", value)
	}

	// Dynamic Array: Will change the value of the myArray in the main()
	myArray[0] = 100
}

func main() {
	// dynamic array
	// Actually a pointer points to the array
	myArray := []int{1, 2, 3, 4}
	printArray(myArray)

	for _, value := range myArray {
		fmt.Println("value =", value)
	}
}

```

### Slice Declaration

```go
func main() {
	// declare slice1 is an array, default values are 1, 2, 3; length = 3
	slice1 := []int{1, 2, 3}

	// declare slice2 is an array, but no space is allocated for slice2
	var slice2 []int
	// Allocate 3 * 8 bytes, default value: 0
	slice2 = make([]int, 3)

	// declare slice3 is an array, allocate 3 * 8 bytes, default value: 0
	var slice3 []int = make([]int, 3)

	// declare slice4 is an array, allocate 3 * 8 bytes, default value: 0
	slice4 := make([]int, 3)

	fmt.Printf("len = %d, slice = %v\n", len(slice1), slice1) // len = 3, slice = [1 2 3]
	fmt.Printf("len = %d, slice = %v\n", len(slice2), slice2) // len = 3, slice = [0 0 0]
	fmt.Printf("len = %d, slice = %v\n", len(slice3), slice3) // len = 3, slice = [0 0 0]
	fmt.Printf("len = %d, slice = %v\n", len(slice4), slice4) // len = 3, slice = [0 0 0]
}
```

### Slice Methods

```go
func main() {
	// 5 is the capacity of the array
	var numbers = make([]int, 3, 5)

	fmt.Printf("len = %d, cap = %d, slice = %v\n", len(numbers), cap(numbers), numbers) // len = 3, cap = 5, slice = [0 0 0]

	// Append a new element to the array, len(numbers) = 4, [0 0 0 1], cap(numbers) = 5
	numbers = append(numbers, 1)
	fmt.Printf("len = %d, cap = %d, slice = %v\n", len(numbers), cap(numbers), numbers)

	// Append a new element to the array, len(numbers) = 5, [0 0 0 1 2], cap(numbers) = 5
	numbers = append(numbers, 2)
	fmt.Printf("len = %d, cap = %d, slice = %v\n", len(numbers), cap(numbers), numbers)

	// Append a new element to the array, len(numbers) = 6, [0 0 0 1 2 3], cap(numbers) = 5 * 2 = 10
	numbers = append(numbers, 3)
	fmt.Printf("len = %d, cap = %d, slice = %v\n", len(numbers), cap(numbers), numbers)

	// [0:2)
	slice1 := numbers[0:2] // here, the pointers of slice1 and numbers points the same array
	fmt.Println(slice1) // [0 0]
	// change the slice1[0] will also change numbers[0]
	slice1[0] = 100

	// copy
	slice2 := make([]int, 3) // [0 0 0]
	copy(slice2, numbers)
	fmt.Println(slice2)
}
```

### map

```go
func main() {
	// Declare myMap1 is a map type, key is string, value is string
	var myMap1 map[string]string
	myMap1 = make(map[string]string, 10)
	myMap1["one"] = "java"
	myMap1["two"] = "c++"
	myMap1["three"] = "python"
	fmt.Println(myMap1)

	// Declare myMap2
	myMap2 := make(map[int]string, 10)
	myMap2[1] = "java"
	myMap2[2] = "c++"
	myMap2[3] = "python"
	fmt.Println(myMap2)

	// Declare myMap3
	myMap3 := map[string]string{
		"one":   "java",
		"two":   "c++",
		"three": "python",
	}
	fmt.Println(myMap3)

	// Delete key-value
	delete(myMap3, "one")
}
```

### struct

```go
type Book struct {
	title string
	auth  string
}

func changeBook(book *Book) {
	book.auth = "Jason" //  Go automatically dereferences struct pointers when accessing fields.
	// Go does not automatically dereference pointers when assigning or reading basic types.
}

func main() {
	var book1 Book
	book1.title = "golang"
	book1.auth = "Larry"
	fmt.Println(book1) // {golang Larry}

	changeBook(&book1)
	fmt.Println(book1) // {golang Larry}
}

```

### class

```go
type Hero struct {
	Name  string
	Ad    int
	Level int
}

func (h Hero) show() {
	fmt.Println("Name =", h.Name)
}

func (h Hero) getName() string {
	return h.Name
}

func (h *Hero) setName(newName string) {
	h.Name = newName
}

func main() {
	hero := Hero{"Larry", 10, 100}
	hero.show()

	// Go automatically converts to (&hero).setName("Jason")
	hero.setName("Jason")
	hero.show()
}

```

### Inheritance

```go
type Human struct {
	name string
	sex  string
}

func (human *Human) Eat() {
	fmt.Println("Human.eat()...")
}

func (human *Human) Walk() {
	fmt.Println("Human.walk()...")
}

type SuperMan struct {
	Human

	level int
}

func (superman *SuperMan) Eat() {
	fmt.Println("SuperMan.Eat()...")
}

func (superman *SuperMan) Fly() {
	fmt.Println("SuperMan.Fly()...")
}

func main() {
	h := Human{"Larry", "female"}
	h.Eat()
	h.Walk()

	s := SuperMan{Human{"Jason", "male"}, 12}
	s.Walk()
	s.Eat()
	s.Fly()
}
```

### interface

```go
// interface is actually a pointer
type AnimalIF interface {
	Sleep()
	GetColor() string
	GetType() string
}

type Cat struct {
	color string
}

func (cat *Cat) Sleep() {
	fmt.Println("Cat is sleeping")
}

func (cat *Cat) GetColor() string {
	return cat.color
}

func (cat *Cat) GetType() string {
	return "Cat"
}

// interface as a type
func showAnimial(animal AnimalIF) {
	animal.Sleep()
	fmt.Println("color = ", animal.GetColor())
	fmt.Println("kind = ", animal.GetType())
}

func main() {
	var animal AnimalIF
	animal = &Cat{"Green"}
	animal.Sleep()

	showAnimial(&Cat{"Red"})
}
```

### type assertion

```go
// interface{} in Golang is like any type in TS
func myFunc(arg interface{}) {
	fmt.Println("myFunc is called...")
	fmt.Println(arg)

	// type assertion
	value, ok := arg.(string)
	if !ok {
		fmt.Println("arg is not string")
	} else {
		fmt.Println("arg is string type, value = ", value)
		fmt.Printf("value type is %T\n", value)
	}
}

type Book struct {
	auth string
}

func main() {
	book := Book{"Golang"}

	myFunc(book)
	myFunc("Hello")
}
```

```go
type Reader interface {
	ReadBook()
}

type Writer interface {
	WriteBook()
}

type Book struct {
}

func (this *Book) ReadBook() {
	fmt.Println("Read a Book")
}
func (this *Book) WriteBook() {
	fmt.Println("Write a Book")
}

func main() {
	b := &Book{}

	var r Reader

	r = b

	r.ReadBook()

	var w Writer
	// r contains a pointer to a Book (*Book) as its concrete value.
	// The compiler checks whether that concrete type (*Book) implements Writer.
	// It does! Because *Book has WriteBook() defined.
	w = r.(Writer)

	w.WriteBook()
}
```