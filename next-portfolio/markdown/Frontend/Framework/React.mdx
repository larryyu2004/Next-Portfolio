# React Tutorial

## Hook

### useMemo()

- Intro: `useMemo()` is a React hook that memoizes the result of a computation so it doesn’t get recalculated on every render, **unless the dependencies change**.
- Avoid expensive calculations on every render.
- Prevent unnecessary re-renders of child components (when passing memoized values as props)

#### 📘 Syntax

- `const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);`

#### Example

```JS
"use client";
import React, { useState, useMemo } from "react";

// A slow factorial function for demonstration
function slowFactorial(n: number): number {
  console.log("🧮 Calculating factorial...");
  if (n <= 1) return 1;
  return n * slowFactorial(n - 1);
}

export default function FactorialComponent() {
  const [number, setNumber] = useState(5);
  const [count, setCount] = useState(0);

  // ❌ This will run on *every* render, even if only `count` changes
  // const factorial = slowFactorial(number);
  const factorial = useMemo(() => slowFactorial(number), [number]);

  return (
    <div className="p-6 max-w-md mx-auto bg-white rounded-2xl shadow-md space-y-4">
      <h2 className="text-xl font-bold text-gray-800">
        Factorial of <span className="text-blue-600">{number}</span> is{" "}
        <span className="text-green-600">{factorial}</span>
      </h2>

      <div className="flex gap-4">
        <button
          onClick={() => setNumber((n) => n + 1)}
          className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
          Increase Number
        </button>

        <button
          onClick={() => setCount((c) => c + 1)}
          className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600">
          Re-render (count = {count})
        </button>
      </div>
    </div>
  );
}
```

- Without `useMemo()`, every time any state updates (like count), FactorialComponent re-renders, and slowFactorial(number) is called again, even if number didn’t change.
- With `useMemo()`, the updates of any state will not invoke `slowFactorial()` function call, because the `useMemo(() => slowFactorial(number), [number]);`'s dependency -> `[number]` doesn't change. `count` state changes here will not affect `const factorial = useMemo(() => slowFactorial(number), [number]);`

### useCallBack()

- Intro: `useCallback()` is a React Hook that returns a memoized version of a function, which only changes if its dependencies change.
- Avoid recreating functions unnecessarily on every render
- Prevent unwanted re-renders of child components that depend on stable function references

#### 🔧 Syntax:

```JS
const memoizedCallback = useCallback(() => {
  // function body
}, [dependencies]);
```

#### Example

```JS
// Item.tsx
import { memo } from "react";
interface ItemProps {
  onChange: () => void;
}
function Item({}: ItemProps) {
  console.log("Item rendered!");
  return <></>;
}

export default memo(Item);
```

```JS
import { useState, useCallback } from "react";

export default function Demo() {
  const [count, setCount] = useState(0);
  const handleChange = useCallback(() => {
    // Cool stuff
  }, []);
  return (
    <div className="tutorial-useCallback">
      <Item onChange={handleChange} />
      <h1>Count: {count} </h1>
      <button className="border-2" onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

| Feature         | Purpose                                                                                                    |
| --------------- | ---------------------------------------------------------------------------------------------------------- |
| `memo()`        | Avoid re-rendering unless props change (Here, `Child` will only re-render when `onClick`or label changes ) |
| `useCallback()` | Keep function reference stable                                                                             |

- So they work together: `memo()` blocks re-renders based on shallow prop comparison while `useCallback()` ensures function props don’t trigger unnecessary renders.

<Key>
  No useCallback(): `Item` Component re-renders every time you click the button.

  With `useCallback()`, Nothing on the dependency changes, it will return the same function every time, so that `Item` Component will not change.
</Key>
