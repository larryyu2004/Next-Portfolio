# Problem: Leetcode 438. Find All Anagrams in a String

## Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.

```C++

Example 1:

Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".

Example 2:

Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
```

---

# Thinking
### FIRST OF ALL, how do we do when it comes to duplicate character?
    1. Delete all the character before the first come of the duplicate character (include the character itself)
### How can we check if now the sliding window is p's anagram in s?

    1. We need two counters:
    2. CounterA is to count the number of the characters in the p
    3. CounterB is to count the number of the characters in the s that are in the sliding window
    4. if CounterA == CounterB -> find the result

---

# PROCESS (Approach 1 - Fixed-Size sliding window)
### Initialization
    1. Initialize the length of the character lists;
    1.1 When window size > length of s (where you can't find the result), return empty list;
    2. Define the res;
```C++
        int sSize = static_cast<int>(s.size());
        int pSize = static_cast<int>(p.size()); // window size
        if(sSize < pSize) return {};
        std::vector<int> res;
```

### Two Counters
    1. Initialize Counter for s
```C++
        std::array<int, 26> cnt_s{};
```
    2. Initialize Counter for p
```C++
        std::array<int, 26> cnt_p{};
        for(char c: p) {
            cnt_p[c - 'a']++;
        }
```

### Window Sliding
    1. Use a for loop to traversal right side
```C++
        for(int right = 0; right < sSize; right++) {
            ...
        }
```

    2. Increase the number of the character on the right side in the siding window
```C++
            cnt_s[s[right] - 'a'] ++;
```

    3.0 Get the left index and also check its validation
    3.1 When left index less than 0 -> window is too small, need more character
```C++
            int left = right - pSize + 1;
            if(left < 0) {
                continue;
            }
```

    4. Check if two counters are same? 
```C++
            if (cnt_p == cnt_s) {
                res.push_back(left);
            }
```

    5. Move the left pointer right (fixed-size)
```C++
            cnt_s[s[left] - 'a']--;
```

### Return
```C++
        return res;
```

---

# COMPLEXITY
Time Complexity: **O(∣Σ∣m+n)**

Space Complexity: **O(∣Σ∣)**

---

# CODE (Approach 1 - Fixed-Size Sliding Window)
```C++
class Solution {
public:
    std::vector<int> findAnagrams(std::string s, std::string p) {
        int sSize = static_cast<int>(s.size());
        int pSize = static_cast<int>(p.size());
        if(sSize < pSize) return {};
        std::vector<int> res;

        std::array<int, 26> cnt_s{};
        std::array<int, 26> cnt_p{};
        for(char c: p) {
            cnt_p[c - 'a']++;
        }

        for(int right = 0; right < sSize; right++) {
            cnt_s[s[right] - 'a'] ++;

            int left = right - pSize + 1;
            if(left < 0) {
                continue;
            }

            if (cnt_p == cnt_s) {
                res.push_back(left);
            }

            cnt_s[s[left] - 'a']--;
        }
        
        return res;
    }
};
```

---
# PROCESS (Approach 2 - Variable-Size Sliding Window)
### Initialization 
1. Initialize the counter
```C++
        std::array<int, 26> cnt{};
        for(char c: p) {
            cnt[c - 'a']++;
        }
```

### Window Sliding
    1. Define the left side
    2. Use a for loop to traversal right side
```C++
        int left = 0;
        for(int right = 0; right < sSize; right++) {
            ...
        }
```

    3.0 If the number of the character in the counter less than 0
    Which means there are too much same characters
    3.1 Then we need to shrink the sliding window from left side
    3.2 Until all the element in the counter are >= 0 
```C++
            int c = s[right] - 'a';
            cnt[c]--;
            while(cnt[c] < 0) {
                cnt[s[left] - 'a']++;
                left++;
            }
```
4.0 When the size of the sliding window is equal to the size of the pSize (target window size), which means find one case
```C++
            if(right - left + 1 == pSize) {
                res.push_back(left);
            }   
```

### Return
```C++
        return res;
```

---

# COMPLEXITY
Time Complexity: **O(m+n)**

Space Complexity: **O(∣Σ∣)**

---

# CODE (Approach 2 - Variable-Size Sliding Window)
```C++
class Solution1 {
public:
    std::vector<int> findAnagrams(std::string s, std::string p) {
        int sSize = static_cast<int>(s.size());
        int pSize = static_cast<int>(p.size());
        if(sSize < pSize) return {};
        std::vector<int> res;

        std::array<int, 26> cnt{};
        for(char c: p) {
            cnt[c - 'a']++;
        }

        int left = 0;
        for(int right = 0; right < sSize; right++) {
            int c = s[right] - 'a';
            cnt[c]--;
            while(cnt[c] < 0) {
                cnt[s[left] - 'a']++;
                left++;
            }

            if(right - left + 1 == pSize) {
                res.push_back(left);
            }   
        }
        return res;
    }
};
```

