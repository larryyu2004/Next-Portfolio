# Unity

## Component

- An object is a combination of components.

1. A cube may have these components: Transform, Cube (Mesh Filter), Mesh Renderer, Box Collider, Move (Script), Rigidbody

### Volume Component

- **Tonemapping** in Unity’s Volume system converts high-dynamic-range (HDR) lighting into something your screen can display. It prevents blown-out highlights and crushed shadows, and gives your scene a more filmic or realistic look depending on the selected mode (like Neutral or ACES).

- **Color Adjustments** in Unity’s Volume system let you tweak the overall look of your scene’s colors after rendering

- **Bloom** makes bright areas in your scene glow by spreading light beyond object edges. It mimics how real cameras and human eyes react to intense brightness, making lights feel soft, cinematic, and more dynamic.

- **Vignette** darkens the edges of the screen to draw attention toward the center, helping guide the player’s focus and adding a subtle cinematic feel.

### Camera Component

#### Randering

- **Anti-aliasing** in the Camera’s Rendering settings controls how smooth the edges of objects look. It reduces the jagged “stair-step” look on diagonal lines. Higher-quality anti-aliasing makes edges smoother but can use more performance.

## PC_RPAsset

### Quality Component

- **Anti-aliasing (MSAA)** will override the **Anti-aliasing** in the camera component if we choose 3D URP

## PC_Renderer

### Screen Space Ambient Occlusion Component

- **Screen Space Ambient Occlusion (SSAO)** adds soft shadows in creases, corners, and where objects are close together. It gives depth and realism by darkening those tiny areas where light would naturally have trouble reaching.

## Player Movement

**Handles:**

- Player movement using Rigidbody
- Detecting and interacting with counters
- Sending walking state to animations

**Key Components**

- GameInput → reads movement + interact input
- Rigidbody → smooth physics-based movement
- Raycast → checks counters in front of player
- selectedCounter → the currently targeted counter

**Update Flow**

- `Update()` → Handle interaction only
- `FixedUpdate()` → Handle movement only (physics)

**Movement**

- Uses Rigidbody.MovePosition ✅
- Slerp rotates player smoothly toward movement direction
- Sets `linearVelocity` & `angularVelocity` to zero to stop physics sliding

**Interaction**

- Raycast forward up to 2m
- If it hits a BaseCounter → select it
- Input event calls selectedCounter.Interact()

**Animation Support**

- IsWalking public read-only property
  → Used by Animator to switch animations

## Camera Follow

## How to add animation & animator

## ScriptableObject

## Design UI

## Managers

- In Unity projects, Managers are super handy for organizing game-wide systems. They usually take care of specific tasks such as handling **audio**, controlling the **game state** (start/pause/game over), managing **UI flow**, and more.
  Because these systems need to be accessed from anywhere, managers are often implemented using the Singleton pattern.

- Because these systems need to be accessed from anywhere, managers are often implemented using the **Singleton pattern**.

```CSharp
public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }
    void Awake()
    {
        Instance = this;
    }
}
```

This sets up a basic singleton:

- Instance gives you global access to the manager.
- `Awake()` ensures the instance is assigned as soon as the object is created.

### Game Manager

#### States

- In the Game Manager, we can define the game moves through some states

```CSharp
private enum State
{
    WaitingToStart,
    CountDownToStart,
    GamePlaying,
    GameOver,
}
```

- And uses three timers to control the game flow.
- Every frame, we decrease the timer based on the current state.

```CSharp
void Update()
{
    switch (state)
    {
        case State.WaitingToStart:
            waitingToStartTimer -= Time.deltaTime;
            if (waitingToStartTimer <= 0)
            {
                TurnToCountDownToStart();
            }
            break;
        case State.CountDownToStart:
            countDownToStartTimer -= Time.deltaTime;
            if (countDownToStartTimer <= 0)
            {
                TurnToGamePlaying();
            }
            break;
        case State.GamePlaying:
            gamePlayingTimer -= Time.deltaTime;
            if (gamePlayingTimer <= 0)
            {
                TurnToGameOver();
            }
            break;
        case State.GameOver:
            break;
        default:
            break;

    }
}
```

#### Changing States (and Notifying UI)
- Whenever the game enters a new state, I fire an event so the UI can update itself.
```CSharp
public event EventHandler OnStateChanged;
```
Each transition looks like this:
```CSharp
private void TurnToGamePlaying()
{
    state = State.GamePlaying;
    EnablePlayer();
    OnStateChanged?.Invoke(this, EventArgs.Empty);
}
```
- This means UI scripts don’t constantly check the state — they simply subscribe and react.

#### Pause & Resume System
- The pause system listens for a pause action from a GameInput script:
```CSharp
GameInput.Instance.OnPauseAction += GameInput_OnPauseAction;
```
When triggered:
```CSharp
public void ToggleGame()
{
    isGamePause = !isGamePause;

    if (isGamePause)
    {
        Time.timeScale = 0; 
        OnGamePaused?.Invoke(this, EventArgs.Empty);
    }
    else
    {
        Time.timeScale = 1;
        OnGameResume?.Invoke(this, EventArgs.Empty);
    }
}
```
- `Time.timeScale = 0` is the classic Unity trick to pause the entire game.
- And just like the state system, pause/resume also triggers events for UI updates.


### Voice Manager
- Singleton Mode

#### Register Voices
- The SoundManager uses a ScriptableObject that holds groups of related sounds:
```CSharp
    [SerializeField] private AudioClipRefsSO audioClipRefsSO;
```
```CSharp
// AudioClipRefsSO.cs
using UnityEngine;

[CreateAssetMenu()]
public class AudioClipRefsSO : ScriptableObject
{
    public AudioClip[] chop;
    public AudioClip[] deliveryFail;
    public AudioClip[] deliverySuccess;
    public AudioClip[] footstep;
    public AudioClip[] objectDrop;
    public AudioClip[] objectPickup;
    public AudioClip[] stoveSizzle;
    public AudioClip[] trash;
    public AudioClip[] warning;
}

```