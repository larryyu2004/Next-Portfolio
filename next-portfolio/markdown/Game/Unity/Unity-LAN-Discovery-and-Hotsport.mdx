# Unity LAN Discovery and Hotsport Support

## GetIPAddress.cs

- This script is designed to reliably get your device’s local IPv4 address, which is required for LAN multiplayer, Unity Transport, and your custom discovery system.
- Because iOS behaves differently from macOS/Windows, the script has two separate logic paths:

1. Path A -> Running on a real iPhone/iPad
2. Path B -> Running in Unity Editor (Mac/PC) or Android

```CSharp
using UnityEngine;
using System.Runtime.InteropServices;
using System.Net.Sockets;
using System.Net.NetworkInformation;
using System.Net;

public class GetIPAddress : MonoBehaviour
{
    // Only include the code inside this block if we are building for an actual iOS device
    // UNITY_IOS: Ensures this code exists when building for iPhone/iPad.
    // UNITY_EDITOR: Ensures this code is removed when you press "Play" in the Unity Editor on your Mac or PC.
    #if UNITY_IOS && !UNITY_EDITOR
    [DllImport("__Internal")]
    private static extern string GetIOSLocalIPAddress();
    #endif

    public static string GetLocalIPAddress()
    {
        // Path A: Real iPhone
        #if UNITY_IOS && !UNITY_EDITOR
        string ipAddress = GetIOSLocalIPAddress();
        Debug.Log("iOS Native IP Found: " + ipAddress);
        return ipAddress;

        // Path B: Mac Unity Editor
        #else
        string localIP = "Error: No Valid IP Found";
        try
        {
            // Loop through all network adapters
            foreach (NetworkInterface ni in NetworkInterface.GetAllNetworkInterfaces())
            {
                // If the cable is unplugged or Wi-Fi is off, ignore it.
                // Ignore "Loopback" (127.0.0.1). That is an internal address for the computer to talk to itself, not to other players.
                // Ignore VPNs. These often have strange IP addresses that won't work for a local Wi-Fi game.
                // Since you are on a Mac, you might have Parallels, Docker, or VMware installed. These create "Virtual" adapters.
                // This line tries to ignore them so you don't accidentally grab a Docker IP instead of your real Wi-Fi IP.
                if (ni.OperationalStatus != OperationalStatus.Up ||
                    ni.NetworkInterfaceType == NetworkInterfaceType.Loopback ||
                    ni.NetworkInterfaceType == NetworkInterfaceType.Tunnel ||
                    ni.Description.ToLower().Contains("virtual"))
                {
                    continue;
                }

                // Extract the IPv4 address
                foreach (UnicastIPAddressInformation ipInfo in ni.GetIPProperties().UnicastAddresses)
                {
                    IPAddress address = ipInfo.Address;

                    // Must be IPv4 (InterNetwork)
                    // Must not be loopback
                    if (address.AddressFamily == AddressFamily.InterNetwork && !IPAddress.IsLoopback(address))
                    {
                        localIP = address.ToString();
                        Debug.Log($"Found Local IP on interface {ni.Name}: {localIP}");
                        return localIP;
                    }
                }
            }
        }
        catch (System.Exception e)
        {
            Debug.LogError($"IP Address Retrieval Error: {e.Message}");
            localIP = "Error: Retrieval Failed";
        }

        Debug.LogError("Failed to find a valid local IPv4 address via C# NetworkInterface iteration.");
        return localIP;

        #endif
    }
}
```

## NetworkDiscovery.cs

This file handles broadcasting (host) and listening (client) using raw UDP sockets.

### Core responsibilities

- Host repeatedly broadcasts its IP address on the LAN (UDP broadcast)
- Client listens for these broadcasts and extracts the host’s IP
- Supports common iOS/Android hotspot subnets
- Runs safely on background threads
- Returns results to Unity’s main thread

## Plugins

### iOS get IP

- This C/C++ code is the implementation side of the bridge. While the C# code was just the "request," this code performs the actual heavy lifting of talking to the iOS operating system to retrieve network information.

```C
// Contains tools to convert computer-readable IP addresses (binary) into human-readable strings (e.g., "192.168.1.5").
#include <arpa/inet.h>
// Contains the getifaddrs function (Get Interface Addresses).
#include <ifaddrs.h>
#include <string.h>
#include <stdlib.h>

// C# calls external function
// C++ compilers usually "mangle" function names (e.g., changing GetIOSLocalIPAddress to _Z20GetIOSLocalIPAddressv to support function overloading).
// extern "C" tells the compiler: "Compile this function using C style naming, not C++." This ensures the function name stays exactly GetIOSLocalIPAddress, allowing Unity (C#) to find it.
extern "C" {
    char* GetIOSLocalIPAddress() {
        struct ifaddrs *interfaces = NULL;
        struct ifaddrs *temp_addr = NULL;
        char* ipAddress = NULL;

        // Ask iOS Kernel to give a linked list of every single network interface on this device
        // Includes Wi-Fi, Cellular (4G/5G), Loopback (localhost), Bluetooth tethering, etc.
        // Stores the result in the interfaces pointer.
        int success = getifaddrs(&interfaces);
        if (success == 0) {
            temp_addr = interfaces;
            while(temp_addr != NULL) {

                // AF_INET stands for Address Family: Internet (IPv4).
                if(temp_addr->ifa_addr->sa_family == AF_INET) {

                    // en0: This is the hardware ID for the Wi-Fi card on almost all iOS devices.
                    // bridge0: This is sometimes used if the phone is acting as a Hotspot or in certain shared-network configurations.
                    // strcmp: String Compare. It checks if the interface name matches "en0".
                    if(strcmp(temp_addr->ifa_name, "en0") == 0 ||
                       strcmp(temp_addr->ifa_name, "bridge0") == 0)
                    {
                        // malloc: Allocates memory on the Heap. We need to do this so the data survives after the function finishes running.
                        ipAddress = (char*)malloc(INET_ADDRSTRLEN);
                        if (ipAddress) {
                            // It takes the raw binary data (sin_addr).
                            // It converts it to a human-readable string (like "192.168.0.1").
                            // It saves it into ipAddress.
                            inet_ntop(AF_INET, &((struct sockaddr_in*)temp_addr->ifa_addr)->sin_addr, ipAddress, INET_ADDRSTRLEN);
                        }
                        break; // Quit the function after finding the IP Address
                    }
                }
                temp_addr = temp_addr->ifa_next;
            }
        }

        // Release list of interfaces using freeifaddrs
        if (interfaces != NULL) {
            freeifaddrs(interfaces);
        }

        // If the loop finishes and ipAddress is still NULL, it means the device isn't connected to Wi-Fi
        if (ipAddress == NULL) {
            ipAddress = (char*)malloc(sizeof(char) * 16); // 15 chars + null terminator
            strcpy(ipAddress, "0.0.0.0");
        }

        return ipAddress;
    }
}
```
